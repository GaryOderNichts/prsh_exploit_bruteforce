/*
 * application.c
 *
 * This source file contains an implementation of the PRSH exploit.
 *
 * The program will attempt to bruteforce the correct address to
 * corrupt for unknown boot1 versions, with the assistance of an external
 * device such as a raspberry pi to automatically reset the console
 * when bad offsets cause the console to lock up.
 *
 * Thanks to
 *  - hexkyz
 *  - derrek6 and his team
 * for the PRSH exploit
 *
 * Copyright (C) 2020 rw-r-r-0644
 * This file is under GNU GPL
 */

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "video/gfx.h"
#include "system/smc.h"
#include "system/memory.h"
#include "system/irq.h"
#include "system/rtc.h"
#include "system/gpio.h"
#include "system/latte.h"
#include "system/crypto.h"
#include "storage/nand.h"
#include "common/utils.h"
#include "storage/sdcard.h"
#include "storage/fatfs/elm.h"
#include "application.h"
#include "payload.h"
#include "prsh.h"

/*
 * IV used for encrypting boot data
 */
static u8
prsh_iv[0x10] =
{
	0x0A, 0xAB, 0xA5, 0x30,
	0x2E, 0x90, 0x12, 0xD9,
	0x08, 0x51, 0x74, 0xE8,
	0x6B, 0x83, 0xEC, 0x22,
};

bool
app_run()
{
	gfx_clear(GFX_ALL, BLACK);
	printf("prsh_dump\n\n");

	/* decrypt */
	u8 iv_buf[0x10];
	memcpy(iv_buf, prsh_iv, 0x10);

	aes_reset();
	aes_set_iv(iv_buf);
	aes_set_key(otp.fw_ancast_key);
	
	aes_decrypt(
		(u8 *)0x10000400,
		(u8 *)0x10000400,
		0x7C00 / 0x10,
		0
	);

	/* read PRSH */
	prsh_t* prsh = (prsh_t *)0x10005A54;

	printf("magic: %08lx\n", prsh->magic);

	//prsh_section_t* section = &prsh->sections[0];


	/* reencrypt prsh */

	memcpy(iv_buf, prsh_iv, 0x10);

	aes_reset();
	aes_set_iv(iv_buf);
	aes_set_key(otp.fw_ancast_key);

	aes_encrypt(
		(u8 *)0x10000400,
		(u8 *)0x10000400,
		0x7C00 / 0x10,
		0
	);

	dc_invalidaterange(
		(u8 *)0x10000400,
		0x7C00
	);

	dc_flushrange(
		(u8 *)0x10000400,
		0x7C00
	);

	udelay(10 * 1000 * 1000);

	// power off
	return false;
}
